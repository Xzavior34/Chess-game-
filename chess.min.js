// chess_engine.js content (to be saved as js/chess.min.js)

const WHITE = 'w';
const BLACK = 'b';
const EMPTY = -1; // Not directly used in board array but good for conceptual clarity
const PAWN = 'p';
const KNIGHT = 'n';
const BISHOP = 'b';
const ROOK = 'r';
const QUEEN = 'q';
const KING = 'k';

const SYMBOLS = 'pnbrqkPNBRQK';
const DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
const TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];

// Constants for piece movement offsets in 0x88 board representation
const PAWN_OFFSETS = {
    b: [16, 32, 17, 15], // black: normal, big_pawn, capture_left, capture_right
    w: [-16, -32, -17, -15] // white: normal, big_pawn, capture_left, capture_right
};
const PIECE_OFFSETS = {
    n: [-18, -33, -31, -14, 18, 33, 31, 14], // Knight moves
    b: [-17, -15, 17, 15], // Bishop moves (diagonals)
    r: [-16, 1, 16, -1], // Rook moves (straights)
    q: [-17, -16, -15, 1, 17, 16, 15, -1], // Queen moves (all 8 directions)
    k: [-17, -16, -15, 1, 17, 16, 15, -1] // King moves (all 8 directions, one step)
};

// Attack and Ray tables (simplified versions for demonstration if not fully implemented)
const ATTACKS = new Array(256).fill(0); // Placeholder
const RAYS = new Array(256).fill(0);     // Placeholder

const SHIFTS = { p: 0, n: 1, b: 2, r: 3, q: 4, k: 5 }; // For the original ATTACKS bitmask.

// Rank constants for pawn promotions and big pawn moves
const RANK_1 = 7; // 0x88 board index rank for White's 1st rank (row 7)
const RANK_2 = 6; // 0x88 board index rank for White's 2nd rank (row 6)
const RANK_7 = 1; // 0x88 board index rank for Black's 7th rank (row 1)
const RANK_8 = 0; // 0x88 board index rank for Black's 8th rank (row 0)

// BITS for move flags
const BITS = {
    NORMAL: 1, CAPTURE: 2, BIG_PAWN: 4, EP_CAPTURE: 8, PROMOTION: 16,
    KSIDE_CASTLE: 32, QSIDE_CASTLE: 64
};

// Castling Rook positions and their flags
const ROOKS = {
    w: [{ square: 112, flag: BITS.QSIDE_CASTLE }, { square: 119, flag: BITS.KSIDE_CASTLE }], // a1, h1
    b: [{ square: 0, flag: BITS.QSIDE_CASTLE }, { square: 7, flag: BITS.KSIDE_CASTLE }]    // a8, h8
};

// Utility to convert square to algebraic notation, e.g., 0 -> a8
function algebraic(square) {
    const file = (square % 16); // File is 0-7 (0x88 files)
    const rank = Math.floor(square / 16); // Rank is 0-7 (0x88 ranks)
    return String.fromCharCode('a'.charCodeAt(0) + file) + (8 - rank);
}

// Utility to convert algebraic notation to square, e.g., 'a8' -> 0
function toSquare(alg) {
    if (alg.length !== 2) return -1;
    const file = alg.charCodeAt(0) - 'a'.charCodeAt(0);
    const rank = 8 - parseInt(alg[1], 10);
    return (rank * 16) + file;
}

// Utility to check if a square is on the board (0x88 check)
function onBoard(square) {
    return (square & 0x88) === 0;
}

// Represents a piece with its type and color
function Piece(type, color) {
    this.type = type;
    this.color = color;
}

// The main Chess game state object
function Chess() {
    let board = new Array(128).fill(null); // 0x88 board
    let turn = WHITE;
    let castling = { w: 0, b: 0 }; // Bitmask for castling rights (QSIDE_CASTLE | KSIDE_CASTLE)
    let epSquare = -1; // En passant target square
    let halfMoves = 0; // Half-move clock for 50-move rule
    let moveNumber = 1;

    let history = []; // Stack to store previous states for undo functionality
    let header = {}; // For PGN headers

    // Pre-calculate 0x88 board mapping - This is redundant as algebraic/toSquare handle it.
    // Keeping it here for consistency with your provided engine code, but it's not strictly used
    // outside of its definition.
    const SQUARES = {};
    const SQUARE_NAMES = [];
    for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
            const square = (i * 16) + j;
            const alg = algebraic(square);
            SQUARES[alg] = square;
            SQUARE_NAMES.push(alg);
        }
    }

    function clearBoard() {
        board.fill(null);
        turn = WHITE;
        castling = { w: 0, b: 0 };
        epSquare = -1;
        halfMoves = 0;
        moveNumber = 1;
        history = [];
        header = {};
        updateCastlingRights(); // Reset castling flags based on ROOKS constant
    }

    function reset() {
        load(DEFAULT_POSITION);
    }

    function load(fen) {
        clearBoard();

        const tokens = fen.split(/\s+/);
        const position = tokens[0];
        turn = tokens[1];
        const castlingRights = tokens[2];
        epSquare = (tokens[3] === '-') ? -1 : toSquare(tokens[3]);
        halfMoves = parseInt(tokens[4], 10);
        moveNumber = parseInt(tokens[5], 10);

        let squareIdx = 0;
        for (let i = 0; i < position.length; i++) {
            const pieceChar = position[i];
            if (pieceChar === '/') {
                squareIdx += 8; // Move to the next rank in 0x88
                continue;
            }

            if (pieceChar >= '0' && pieceChar <= '9') {
                squareIdx += parseInt(pieceChar, 10);
            } else {
                const color = (pieceChar === pieceChar.toUpperCase()) ? WHITE : BLACK;
                const type = pieceChar.toLowerCase();
                board[to0x88(squareIdx)] = new Piece(type, color);
                squareIdx++;
            }
        }

        // Parse castling rights
        castling.w = 0;
        castling.b = 0;
        if (castlingRights.includes('K')) castling.w |= BITS.KSIDE_CASTLE;
        if (castlingRights.includes('Q')) castling.w |= BITS.QSIDE_CASTLE;
        if (castlingRights.includes('k')) castling.b |= BITS.KSIDE_CASTLE;
        if (castlingRights.includes('q')) castling.b |= BITS.QSIDE_CASTLE;

        updateCastlingRights(); // Update the internal castling flags
        pushState(); // Store initial state in history
    }

    function to0x88(idx64) {
        // Converts a 0-63 (standard) board index to 0x88 index
        const rank = Math.floor(idx64 / 8);
        const file = idx64 % 8;
        return (rank * 16) + file;
    }

    // function to64(idx0x88) { // This function is not used internally by the engine
    //     // Converts a 0x88 index to a 0-63 (standard) board index
    //     return (Math.floor(idx0x88 / 16) * 8) + (idx0x88 % 16);
    // }

    function generateFen() {
        let emptyCount = 0;
        let fen = '';
        for (let i = 0; i < 8; i++) { // Ranks (0-7)
            for (let j = 0; j < 8; j++) { // Files (0-7)
                const square = (i * 16) + j;
                const piece = board[square];

                if (piece === null) {
                    emptyCount++;
                } else {
                    if (emptyCount > 0) {
                        fen += emptyCount;
                        emptyCount = 0;
                    }
                    fen += (piece.color === WHITE) ? piece.type.toUpperCase() : piece.type;
                }
            }
            if (emptyCount > 0) {
                fen += emptyCount;
                emptyCount = 0;
            }
            if (i < 7) {
                fen += '/';
            }
        }

        fen += ' ' + turn;

        let castlingStr = '';
        if (castling.w & BITS.KSIDE_CASTLE) castlingStr += 'K';
        if (castling.w & BITS.QSIDE_CASTLE) castlingStr += 'Q';
        if (castling.b & BITS.KSIDE_CASTLE) castlingStr += 'k';
        if (castling.b & BITS.QSIDE_CASTLE) castlingStr += 'q';
        fen += ' ' + (castlingStr === '' ? '-' : castlingStr);

        fen += ' ' + (epSquare === -1 ? '-' : algebraic(epSquare));
        fen += ' ' + halfMoves;
        fen += ' ' + moveNumber;

        return fen;
    }

    function pushState() {
        history.push({
            board: board.slice(), // Deep copy of the board array
            turn: turn,
            castling: { w: castling.w, b: castling.b },
            epSquare: epSquare,
            halfMoves: halfMoves,
            moveNumber: moveNumber
        });
    }

    function popState() { // This function is not used internally for undo
        if (history.length === 0) return null;
        const state = history.pop();
        board = state.board;
        turn = state.turn;
        castling = state.castling;
        epSquare = state.epSquare;
        halfMoves = state.halfMoves;
        moveNumber = state.moveNumber;
        return state;
    }

    function get(square) {
        // Returns the piece at the given square (algebraic or 0x88 index)
        if (typeof square === 'string') {
            square = toSquare(square);
        }
        if (!onBoard(square)) return null;
        return board[square];
    }

    function put(piece, square) {
        // Puts a piece on the given square
        if (typeof square === 'string') {
            square = toSquare(square);
        }
        if (!onBoard(square)) return null;

        const oldPiece = board[square];
        board[square] = piece;
        updateCastlingRights(square, oldPiece); // Update castling for removal/placement
        return oldPiece;
    }

    function remove(square) {
        // Removes a piece from the given square
        if (typeof square === 'string') {
            square = toSquare(square);
        }
        if (!onBoard(square)) return null;

        const piece = board[square];
        board[square] = null;
        updateCastlingRights(square, piece); // Update castling for removal
        return piece;
    }

    // --- Move Generation Logic ---
    function generateMoves(options) {
        options = options || {};
        const legalOnly = options.legal || true; // Default to legal moves
        const moves = [];

        const us = turn;
        const them = (turn === WHITE) ? BLACK : WHITE;
        const ourKingSquare = findKing(us);

        if (ourKingSquare === -1) return []; // Should not happen in a valid game

        for (let i = 0; i < 128; i++) {
            if (!onBoard(i)) continue;
            const piece = board[i];
            if (piece === null || piece.color !== us) continue;

            if (piece.type === PAWN) {
                addPawnMoves(moves, i, piece.color, us, them);
            } else if (piece.type === KNIGHT) {
                addKnightMoves(moves, i, piece.color, us, them);
            } else if (piece.type === BISHOP) {
                addSlidingMoves(moves, i, piece.color, BISHOP, PIECE_OFFSETS.b, us, them);
            } else if (piece.type === ROOK) {
                addSlidingMoves(moves, i, piece.color, ROOK, PIECE_OFFSETS.r, us, them);
            } else if (piece.type === QUEEN) {
                addSlidingMoves(moves, i, piece.color, QUEEN, PIECE_OFFSETS.q, us, them);
            } else if (piece.type === KING) {
                addKingMoves(moves, i, piece.color, us, them);
            }
        }

        // Add Castling moves
        // The castling check in generateMoves should consider if the king is in check.
        // It's also important to check if the squares the king *moves through* are attacked.
        if (options.castle && !isKingInCheck(us, ourKingSquare)) {
            addCastlingMoves(moves, us);
        }

        if (legalOnly) {
            return moves.filter(move => !isKingInCheckAfterMove(us, move));
        }
        return moves;
    }

    function addPawnMoves(moves, from, color, us, them) {
        const rank = Math.floor(from / 16);
        const file = from % 16;
        const isWhite = (color === WHITE);

        // Normal 1-step move
        let target = from + PAWN_OFFSETS[color][0];
        if (onBoard(target) && board[target] === null) {
            addMove(moves, from, target, BITS.NORMAL, PAWN);
            // Big pawn move
            if ((isWhite && rank === RANK_2) || (!isWhite && rank === RANK_7)) {
                target = from + PAWN_OFFSETS[color][1];
                if (onBoard(target) && board[target] === null) {
                    addMove(moves, from, target, BITS.BIG_PAWN, PAWN);
                }
            }
        }

        // Captures
        for (let i = 2; i < 4; i++) { // Capture left/right offsets
            target = from + PAWN_OFFSETS[color][i];
            // Check if the target is on board and contains an opponent's piece
            if (onBoard(target)) {
                const targetPiece = board[target];
                if (targetPiece !== null && targetPiece.color === them) {
                    addMove(moves, from, target, BITS.CAPTURE, PAWN, targetPiece.type);
                }
            }
        }

        // En Passant
        if (epSquare !== -1) {
            for (let i = 2; i < 4; i++) { // Capture left/right offsets
                target = from + PAWN_OFFSETS[color][i];
                if (onBoard(target) && target === epSquare) {
                    // Check if the captured pawn is actually there logically (behind epSquare from pawn perspective)
                    const capturedPawnSquare = isWhite ? epSquare + 16 : epSquare - 16;
                    if (onBoard(capturedPawnSquare) && board[capturedPawnSquare] && board[capturedPawnSquare].type === PAWN && board[capturedPawnSquare].color === them) {
                        addMove(moves, from, epSquare, BITS.EP_CAPTURE, PAWN, PAWN);
                    }
                }
            }
        }
    }

    function addKnightMoves(moves, from, color, us, them) {
        for (const offset of PIECE_OFFSETS.n) {
            const target = from + offset;
            if (onBoard(target)) {
                const targetPiece = board[target];
                if (targetPiece === null) {
                    addMove(moves, from, target, BITS.NORMAL, KNIGHT);
                } else if (targetPiece.color === them) {
                    addMove(moves, from, target, BITS.CAPTURE, KNIGHT, targetPiece.type);
                }
            }
        }
    }

    function addSlidingMoves(moves, from, color, type, offsets, us, them) {
        for (const offset of offsets) {
            let target = from + offset;
            while (onBoard(target)) {
                const targetPiece = board[target];
                if (targetPiece === null) {
                    addMove(moves, from, target, BITS.NORMAL, type);
                } else {
                    if (targetPiece.color === them) {
                        addMove(moves, from, target, BITS.CAPTURE, type, targetPiece.type);
                    }
                    break; // Blocked by own piece or captured opponent piece
                }
                target += offset;
            }
        }
    }

    function addKingMoves(moves, from, color, us, them) {
        for (const offset of PIECE_OFFSETS.k) {
            const target = from + offset;
            if (onBoard(target)) {
                const targetPiece = board[target];
                if (targetPiece === null) {
                    addMove(moves, from, target, BITS.NORMAL, KING);
                } else if (targetPiece.color === them) {
                    addMove(moves, from, target, BITS.CAPTURE, KING, targetPiece.type);
                }
            }
        }
    }

    function addCastlingMoves(moves, color) {
        const kingRank = (color === WHITE) ? RANK_1 : RANK_8;
        const kingSquare = (color === WHITE) ? toSquare('e1') : toSquare('e8');

        // King-side castling
        if (castling[color] & BITS.KSIDE_CASTLE) {
            const hRookSquare = (color === WHITE) ? toSquare('h1') : toSquare('h8');
            // Check if king and rook are in original positions and intervening squares are empty
            if (board[kingSquare] && board[kingSquare].type === KING && board[kingSquare].color === color &&
                board[hRookSquare] && board[hRookSquare].type === ROOK && board[hRookSquare].color === color &&
                board[kingSquare + 1] === null && board[kingSquare + 2] === null) {
                // Check if squares are attacked
                if (!isSquareAttacked(kingSquare, color) &&
                    !isSquareAttacked(kingSquare + 1, color) &&
                    !isSquareAttacked(kingSquare + 2, color)) {
                    addMove(moves, kingSquare, kingSquare + 2, BITS.KSIDE_CASTLE, KING);
                }
            }
        }

        // Queen-side castling
        if (castling[color] & BITS.QSIDE_CASTLE) {
            const aRookSquare = (color === WHITE) ? toSquare('a1') : toSquare('a8');
            // Check if king and rook are in original positions and intervening squares are empty
            if (board[kingSquare] && board[kingSquare].type === KING && board[kingSquare].color === color &&
                board[aRookSquare] && board[aRookSquare].type === ROOK && board[aRookSquare].color === color &&
                board[kingSquare - 1] === null && board[kingSquare - 2] === null && board[kingSquare - 3] === null) {
                // Check if squares are attacked
                if (!isSquareAttacked(kingSquare, color) &&
                    !isSquareAttacked(kingSquare - 1, color) &&
                    !isSquareAttacked(kingSquare - 2, color)) {
                    addMove(moves, kingSquare, kingSquare - 2, BITS.QSIDE_CASTLE, KING);
                }
            }
        }
    }

    function addMove(moves, from, to, flags, pieceType, capturedType = null) {
        const move = {
            from: from,
            to: to,
            piece: pieceType,
            flags: flags,
            captured: capturedType, // Store captured piece type
            promotion: null // Placeholder for promotion type
        };

        // Handle pawn promotions
        if (pieceType === PAWN) {
            const targetRank = Math.floor(to / 16);
            if ((turn === WHITE && targetRank === RANK_8) || (turn === BLACK && targetRank === RANK_1)) {
                // Promotion moves - add moves for all promotion types
                ['q', 'r', 'b', 'n'].forEach(promoType => {
                    const promoMove = { ...move, flags: flags | BITS.PROMOTION, promotion: promoType };
                    moves.push(promoMove);
                });
                return; // Don't add the basic pawn move if it's a promotion
            }
        }
        moves.push(move);
    }

    function move(moveObj) {
        if (typeof moveObj === 'string') {
            moveObj = newMove(moveObj); // Parse a string move
        }

        // First, check if the move is in the list of legal moves generated
        const legalMoves = generateMoves({ legal: true, castle: true });
        let foundLegalMove = null;

        for (const legal of legalMoves) {
            if (legal.from === moveObj.from &&
                legal.to === moveObj.to &&
                legal.piece === moveObj.piece) {
                // If it's a promotion, ensure the promotion type matches
                if ((legal.flags & BITS.PROMOTION) && legal.promotion !== moveObj.promotion) {
                    continue;
                }
                foundLegalMove = legal;
                break;
            }
        }

        if (!foundLegalMove) return null; // Not a legal move

        pushState(); // Save current state

        const from = foundLegalMove.from;
        const to = foundLegalMove.to;
        const piece = board[from];

        // Reset en passant square for the next turn
        epSquare = -1;
        halfMoves++;

        // Basic move: move piece from 'from' to 'to'
        board[to] = piece;
        board[from] = null;

        // Handle special flags
        if (foundLegalMove.flags & BITS.CAPTURE) {
            halfMoves = 0; // Reset half-move clock on capture
        }

        if (foundLegalMove.flags & BITS.BIG_PAWN) {
            epSquare = (turn === WHITE) ? (to + 16) : (to - 16);
        }

        if (foundLegalMove.flags & BITS.EP_CAPTURE) {
            // Remove the actual pawn that was captured en passant
            const capturedPawnSquare = (turn === WHITE) ? (to + 16) : (to - 16);
            board[capturedPawnSquare] = null;
        }

        if (foundLegalMove.flags & BITS.PROMOTION) {
            board[to] = new Piece(foundLegalMove.promotion, turn);
        }

        if (foundLegalMove.flags & BITS.KSIDE_CASTLE) {
            const rookFrom = (turn === WHITE) ? toSquare('h1') : toSquare('h8');
            const rookTo = (turn === WHITE) ? toSquare('f1') : toSquare('f8');
            board[rookTo] = board[rookFrom];
            board[rookFrom] = null;
        }

        if (foundLegalMove.flags & BITS.QSIDE_CASTLE) {
            const rookFrom = (turn === WHITE) ? toSquare('a1') : toSquare('a8');
            const rookTo = (turn === WHITE) ? toSquare('d1') : toSquare('d8');
            board[rookTo] = board[rookFrom];
            board[rookFrom] = null;
        }

        // Update castling rights based on king and rook moves
        // These are complex rules, simplified here
        if (piece.type === KING) {
            castling[turn] = 0; // King moves, loses all castling rights
        } else if (piece.type === ROOK) {
            if (from === toSquare('a1') || from === toSquare('h1')) { // White rooks
                if (turn === WHITE) {
                    if (from === toSquare('a1')) castling.w &= ~BITS.QSIDE_CASTLE;
                    if (from === toSquare('h1')) castling.w &= ~BITS.KSIDE_CASTLE;
                }
            } else if (from === toSquare('a8') || from === toSquare('h8')) { // Black rooks
                if (turn === BLACK) {
                    if (from === toSquare('a8')) castling.b &= ~BITS.QSIDE_CASTLE;
                    if (from === toSquare('h8')) castling.b &= ~BITS.KSIDE_CASTLE;
                }
            }
        }
        // If a rook is captured on its original square, the opponent loses that castling right
        // This is handled by updating the castling rights when `put` or `remove` are called,
        // which isn't happening directly inside `move`'s main logic.
        // For a capture, the `captured` piece's original square matters.
        if (foundLegalMove.flags & BITS.CAPTURE) {
            if (foundLegalMove.captured === ROOK) {
                // If a rook was captured, and it was on its original castling square
                if (to === toSquare('a1') || to === toSquare('h1')) {
                    if (turn === BLACK) { // Black captured white rook
                        if (to === toSquare('a1')) castling.w &= ~BITS.QSIDE_CASTLE;
                        if (to === toSquare('h1')) castling.w &= ~BITS.KSIDE_CASTLE;
                    }
                } else if (to === toSquare('a8') || to === toSquare('h8')) {
                    if (turn === WHITE) { // White captured black rook
                        if (to === toSquare('a8')) castling.b &= ~BITS.QSIDE_CASTLE;
                        if (to === toSquare('h8')) castling.b &= ~BITS.KSIDE_CASTLE;
                    }
                }
            }
        }


        // Change turn
        turn = (turn === WHITE) ? BLACK : WHITE;
        if (turn === WHITE) {
            moveNumber++;
        }

        // Return the move object with all flags and data
        return foundLegalMove;
    }

    function undo() {
        if (history.length <= 1) { // Only the initial state remains, cannot undo further
            return null;
        }
        history.pop(); // Remove current state
        const prevState = history[history.length - 1]; // Get previous state
        board = prevState.board.slice(); // Restore board from saved copy
        turn = prevState.turn;
        castling = { w: prevState.castling.w, b: prevState.castling.b }; // Restore castling rights
        epSquare = prevState.epSquare;
        halfMoves = prevState.halfMoves;
        moveNumber = prevState.moveNumber;
        return true;
    }

    // This isValidMove function is not strictly needed if move() calls generateMoves() first
    // and only performs legal moves. But keeping it as it was in your engine structure.
    function isValidMove(moveObj) {
        const possibleMoves = generateMoves({ legal: true, castle: true }); // Generate all legal moves

        for (const possible of possibleMoves) {
            // Compare relevant fields for move equality
            if (possible.from === moveObj.from &&
                possible.to === moveObj.to &&
                possible.piece === moveObj.piece) {
                // If promotion, check promotion type
                if ((possible.flags & BITS.PROMOTION) && possible.promotion !== moveObj.promotion) {
                    continue;
                }
                return true;
            }
        }
        return false;
    }

    // Converts a string like 'e2e4' or 'e7e8q' into a move object
    function newMove(moveString) {
        if (moveString.length < 4 || moveString.length > 5) return null;

        const fromAlg = moveString.substring(0, 2);
        const toAlg = moveString.substring(2, 4);
        const promotionType = (moveString.length === 5) ? moveString[4] : null;

        const from = toSquare(fromAlg);
        const to = toSquare(toAlg);

        if (!onBoard(from) || !onBoard(to)) return null;

        const piece = board[from];
        if (!piece || piece.color !== turn) return null; // No piece or not current player's piece

        let flags = BITS.NORMAL;
        let captured = null;

        const targetPiece = board[to];
        if (targetPiece) {
            if (targetPiece.color === turn) return null; // Cannot capture own piece
            flags |= BITS.CAPTURE;
            captured = targetPiece.type;
        }

        // Check for specific flags based on piece type and move
        if (piece.type === PAWN) {
            if (Math.abs(from - to) === 32) { // Big pawn move (e.g., e2e4)
                flags |= BITS.BIG_PAWN;
            } else if (to === epSquare) { // En passant capture
                flags |= BITS.EP_CAPTURE;
                captured = PAWN; // En passant always captures a pawn
            } else if ((turn === WHITE && Math.floor(to / 16) === RANK_8) || (turn === BLACK && Math.floor(to / 16) === RANK_1)) {
                if (!promotionType) return null; // Promotion requires a type
                flags |= BITS.PROMOTION;
            }
        } else if (piece.type === KING) {
            if (Math.abs(from - to) === 2) { // Castling (e.g., e1g1 for kingside, e1c1 for queenside)
                if (to === toSquare('g1') || to === toSquare('g8')) {
                    flags |= BITS.KSIDE_CASTLE;
                } else if (to === toSquare('c1') || to === toSquare('c8')) {
                    flags |= BITS.QSIDE_CASTLE;
                } else {
                    return null; // Invalid king move that looks like castling
                }
            }
        }

        return {
            from: from,
            to: to,
            piece: piece.type,
            flags: flags,
            captured: captured,
            promotion: promotionType
        };
    }


    function findKing(color) {
        for (let i = 0; i < 128; i++) {
            if (onBoard(i)) {
                const piece = board[i];
                if (piece && piece.type === KING && piece.color === color) {
                    return i;
                }
            }
        }
        return -1; // Should not happen in a valid game
    }

    function isSquareAttacked(square, attackerColor) {
        const defenderColor = (attackerColor === WHITE) ? BLACK : WHITE; // This variable is not used

        // Check for pawn attacks
        const pawnOffsets = PAWN_OFFSETS[attackerColor];
        for (let i = 2; i < 4; i++) { // Capture offsets
            const from = square - pawnOffsets[i]; // Reverse the offset to find attacking pawns
            if (onBoard(from)) {
                const piece = board[from];
                if (piece && piece.type === PAWN && piece.color === attackerColor) {
                    return true;
                }
            }
        }

        // Check for knight attacks
        for (const offset of PIECE_OFFSETS.n) {
            const from = square - offset; // Reverse the offset
            if (onBoard(from)) {
                const piece = board[from];
                if (piece && piece.type === KNIGHT && piece.color === attackerColor) {
                    return true;
                }
            }
        }

        // Check for sliding piece attacks (Bishop, Rook, Queen)
        // Check diagonals (Bishop, Queen)
        for (const offset of PIECE_OFFSETS.b) {
            let from = square + offset; // Start from the attacked square and move outwards
            while (onBoard(from)) {
                const piece = board[from];
                if (piece) {
                    if (piece.color === attackerColor && (piece.type === BISHOP || piece.type === QUEEN)) {
                        return true;
                    }
                    break; // Blocked by own piece or opponent piece
                }
                from += offset;
            }
        }

        // Check straights (Rook, Queen)
        for (const offset of PIECE_OFFSETS.r) {
            let from = square + offset; // Start from the attacked square and move outwards
            while (onBoard(from)) {
                const piece = board[from];
                if (piece) {
                    if (piece.color === attackerColor && (piece.type === ROOK || piece.type === QUEEN)) {
                        return true;
                    }
                    break; // Blocked by own piece or opponent piece
                }
                from += offset;
            }
        }

        // Check for King attacks (one step in any direction)
        for (const offset of PIECE_OFFSETS.k) {
            const from = square - offset; // Reverse the offset
            if (onBoard(from)) {
                const piece = board[from];
                if (piece && piece.type === KING && piece.color === attackerColor) {
                    return true;
                }
            }
        }
        return false;
    }

    function isKingInCheck(color, kingSquare = findKing(color)) {
        if (kingSquare === -1) return false; // King not on board (shouldn't happen in a valid game state)
        const opponentColor = (color === WHITE) ? BLACK : WHITE;
        return isSquareAttacked(kingSquare, opponentColor);
    }

    function isKingInCheckAfterMove(color, move) {
        // Temporarily apply the move to a cloned board state
        const originalBoard = board.slice(); // Slice creates a shallow copy, but board elements are objects
        // For deep copy of pieces, if pieces were mutable objects:
        // const originalBoard = board.map(p => p ? new Piece(p.type, p.color) : null);

        const originalEpSquare = epSquare;
        const originalCastlingW = castling.w;
        const originalCastlingB = castling.b;

        const from = move.from;
        const to = move.to;
        const piece = board[from]; // Get the piece before moving it

        // Apply the move on the temporary board
        board[to] = piece;
        board[from] = null;

        if (move.flags & BITS.EP_CAPTURE) {
            const capturedPawnSquare = (color === WHITE) ? (to + 16) : (to - 16);
            board[capturedPawnSquare] = null;
        }
        if (move.flags & BITS.PROMOTION) {
            board[to] = new Piece(move.promotion, color);
        }
        if (move.flags & BITS.KSIDE_CASTLE) {
            const rookFrom = (color === WHITE) ? toSquare('h1') : toSquare('h8');
            const rookTo = (color === WHITE) ? toSquare('f1') : toSquare('f8');
            board[rookTo] = board[rookFrom];
            board[rookFrom] = null;
        }
        if (move.flags & BITS.QSIDE_CASTLE) {
            const rookFrom = (color === WHITE) ? toSquare('a1') : toSquare('a8');
            const rookTo = (color === WHITE) ? toSquare('d1') : toSquare('d8');
            board[rookTo] = board[rookFrom];
            board[rookFrom] = null;
        }

        const kingSquare = findKing(color); // Find king's new position
        const inCheck = isKingInCheck(color, kingSquare);

        // Revert the board to its original state
        board = originalBoard;
        epSquare = originalEpSquare;
        castling.w = originalCastlingW;
        castling.b = originalCastlingB;

        return inCheck;
    }

    function inCheck() {
        return isKingInCheck(turn);
    }

    function inCheckmate() {
        return inCheck() && generateMoves({ legal: true, castle: true }).length === 0;
    }

    function inStalemate() {
        return !inCheck() && generateMoves({ legal: true, castle: true }).length === 0;
    }

    function insufficientMaterial() {
        const pieces = [];
        for (let i = 0; i < 128; i++) {
            if (onBoard(i) && board[i]) {
                pieces.push(board[i]);
            }
        }

        // Two kings only
        if (pieces.length === 2) {
            return true;
        }

        let whiteBishops = 0;
        let blackBishops = 0;
        let whiteKnights = 0;
        let blackKnights = 0;
        let otherPieces = 0; // Pawns, Rooks, Queens

        for (const p of pieces) {
            if (p.type === PAWN || p.type === ROOK || p.type === QUEEN) {
                otherPieces++;
            } else if (p.type === BISHOP) {
                if (p.color === WHITE) whiteBishops++;
                else blackBishops++;
            } else if (p.type === KNIGHT) {
                if (p.color === WHITE) whiteKnights++;
                else blackKnights++;
            }
        }

        if (otherPieces > 0) return false; // If there are pawns, rooks, or queens, not insufficient

        // King and Bishop vs King
        // King and Knight vs King
        if ((whiteBishops + blackBishops + whiteKnights + blackKnights) === 1) return true;

        // King and Bishop vs King and Bishop on same colored squares
        // This is complex to check without tracking square colors for bishops.
        // For simplicity, we'll assume not insufficient if multiple bishops, unless specific patterns are checked.
        // The most common insufficient materials are K vs K, K vs KB, K vs KN, KN vs KN (if same color squares are not forced), KB vs KB (if same color squares).
        // This simplified check should cover the most basic cases.
        if (whiteKnights === 0 && blackKnights === 0 && whiteBishops === 1 && blackBishops === 1) {
             // This is the case K+B vs K+B. Determining if they are same-color bishops
             // would require storing the square color of the bishop in the piece object,
             // or calculating it. Without that, we return false (not insufficient).
             return false; // Assuming not insufficient unless more sophisticated check
        }

        return false; // Default to not insufficient unless clear case
    }


    function inThreefoldRepetition() {
        const currentFenNoMoves = generateFen().split(' ').slice(0, 4).join(' '); // Get board state, turn, castling, epSquare
        let count = 0;
        // Iterate through history to find matching states
        for (let i = 0; i < history.length; i++) {
            const histFenNoMoves = generateFenFromHistory(history[i]).split(' ').slice(0, 4).join(' ');
            if (histFenNoMoves === currentFenNoMoves) {
                count++;
            }
        }
        return count >= 3;
    }

    function inDraw() {
        return halfMoves >= 100 || inStalemate() || insufficientMaterial() || inThreefoldRepetition();
    }

    function gameOver() {
        return inCheckmate() || inStalemate() || inDraw();
    }

    function setHeader(args) {
        for (let i = 0; i < args.length; i += 2) {
            if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {
                header[args[i]] = args[i + 1];
            }
        }
        return header;
    }

    // This function can be called after any board modification (put, remove, move)
    // to ensure castling rights are correctly updated.
    function updateCastlingRights() {
        // White King has moved
        if (board[toSquare('e1')] === null || board[toSquare('e1')].type !== KING || board[toSquare('e1')].color !== WHITE) {
            castling.w = 0;
        }
        // White King-side Rook has moved or been captured
        if (board[toSquare('h1')] === null || board[toSquare('h1')].type !== ROOK || board[toSquare('h1')].color !== WHITE) {
            castling.w &= ~BITS.KSIDE_CASTLE;
        }
        // White Queen-side Rook has moved or been captured
        if (board[toSquare('a1')] === null || board[toSquare('a1')].type !== ROOK || board[toSquare('a1')].color !== WHITE) {
            castling.w &= ~BITS.QSIDE_CASTLE;
        }

        // Black King has moved
        if (board[toSquare('e8')] === null || board[toSquare('e8')].type !== KING || board[toSquare('e8')].color !== BLACK) {
            castling.b = 0;
        }
        // Black King-side Rook has moved or been captured
        if (board[toSquare('h8')] === null || board[toSquare('h8')].type !== ROOK || board[toSquare('h8')].color !== BLACK) {
            castling.b &= ~BITS.KSIDE_CASTLE;
        }
        // Black Queen-side Rook has moved or been captured
        if (board[toSquare('a8')] === null || board[toSquare('a8')].type !== ROOK || board[toSquare('a8')].color !== BLACK) {
            castling.b &= ~BITS.QSIDE_CASTLE;
        }
    }


    // Public API for the Chess object
    return {
        load: load,
        reset: reset,
        fen: generateFen,
        // The `moves` function in your engine returns move objects, not SAN strings
        moves: generateMoves,
        move: move,
        undo: undo,
        put: put,
        get: get,
        remove: remove,
        inCheck: inCheck,
        inCheckmate: inCheckmate,
        inStalemate: inStalemate,
        inThreefoldRepetition: inThreefoldRepetition,
        insufficientMaterial: insufficientMaterial,
        inDraw: inDraw,
        gameOver: gameOver,
        header: setHeader,
        turn: () => turn,
        history: () => history.map(h => ({
            fen: generateFenFromHistory(h), // Helper to reconstruct FEN from history state
            move: null // Could add the move that led to this state if stored in history
        })),
        board: () => {
            // Returns a 2D array representation for easier rendering in the UI
            const board2D = [];
            for (let i = 0; i < 8; i++) { // Ranks 0-7
                const row = [];
                for (let j = 0; j < 8; j++) { // Files 0-7
                    const square0x88 = (i * 16) + j;
                    const piece = board[square0x88];
                    row.push(piece ? { type: piece.type, color: piece.color } : null);
                }
                board2D.push(row);
            }
            return board2D;
        },
        squareColors: () => { // Not used by current UI, but part of your engine's API
            const colors = {};
            for (let i = 0; i < 128; i++) {
                if (onBoard(i)) {
                    const file = i % 16;
                    const rank = Math.floor(i / 16);
                    colors[algebraic(i)] = ((file + rank) % 2 === 0) ? 'light' : 'dark';
                }
            }
            return colors;
        }
    };
}

// Helper to reconstruct FEN from a history state object (used for `history()` method)
function generateFenFromHistory(state) {
    let emptyCount = 0;
    let fen = '';
    for (let i = 0; i < 8; i++) { // Ranks (0-7)
        for (let j = 0; j < 8; j++) { // Files (0-7)
            const square = (i * 16) + j;
            const piece = state.board[square];

            if (piece === null) {
                emptyCount++;
            } else {
                if (emptyCount > 0) {
                    fen += emptyCount;
                    emptyCount = 0;
                }
                fen += (piece.color === WHITE) ? piece.type.toUpperCase() : piece.type;
            }
        }
        if (emptyCount > 0) {
            fen += emptyCount;
            emptyCount = 0;
        }
        if (i < 7) {
            fen += '/';
        }
    }

    fen += ' ' + state.turn;

    let castlingStr = '';
    if (state.castling.w & BITS.KSIDE_CASTLE) castlingStr += 'K';
    if (state.castling.w & BITS.QSIDE_CASTLE) castlingStr += 'Q';
    if (state.castling.b & BITS.KSIDE_CASTLE) castlingStr += 'k';
    if (state.castling.b & BITS.QSIDE_CASTLE) castlingStr += 'q';
    fen += ' ' + (castlingStr === '' ? '-' : castlingStr);

    fen += ' ' + (state.epSquare === -1 ? '-' : algebraic(state.epSquare));
    fen += ' ' + state.halfMoves;
    fen += ' ' + state.moveNumber;

    return fen;
}
