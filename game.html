<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Xzavior Chess - Game</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      background-color: #f7f7f7;
      text-align: center;
      padding: 20px;
      margin: 0;
    }
    #chessboard {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      width: 95vmin;
      max-width: 500px;
      height: 95vmin;
      max-height: 500px;
      margin: 0 auto;
      border: 2px solid #333;
    }
    .square {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 4vmin;
      user-select: none;
    }
    .white { background: #f0d9b5; }
    .black { background: #b58863; }
    .selected { outline: 3px solid yellow; }
    .highlight { background-color: rgba(0, 255, 0, 0.4) !important; }
    #status { margin-top: 10px; font-size: 18px; }
  </style>
</head>
<body>
  <h2>Xzavior Chess</h2>
  <div id="chessboard"></div>
  <div id="status">Loading...</div>
  <div class="mt-3">
    <button class="btn btn-warning" onclick="undoMove()">Undo Move</button>
    <button class="btn btn-secondary" onclick="saveGame()">Save Game</button>
    <button class="btn btn-danger" onclick="restartGame()">Restart</button>
  </div>

  <!-- Use chess.js from CDN -->
  <script src="https://unpkg.com/chess.js@0.13.4/chess.min.js"></script>

  <script>
    const config = JSON.parse(localStorage.getItem("xzaviorGameSettings") || '{}');
    const game = new Chess();
    const board = document.getElementById("chessboard");
    const status = document.getElementById("status");

    let selected = null;
    let playerColor = config.side || "white";
    let gameMode = config.mode || "human";
    let difficulty = parseInt(config.difficulty || 1);

    function pieceToSymbol(piece) {
      const map = {
        p: "♟", r: "♜", n: "♞", b: "♝", q: "♛", k: "♚",
        P: "♙", R: "♖", N: "♘", B: "♗", Q: "♕", K: "♔"
      };
      return map[piece] || "";
    }

    function renderBoard() {
      board.innerHTML = "";
      const position = game.fen().split(" ")[0];
      const rows = position.split("/");
      rows.forEach((row, r) => {
        let fileIndex = 0;
        for (let ch of row) {
          const isNum = !isNaN(ch);
          const count = isNum ? parseInt(ch) : 1;
          for (let i = 0; i < count; i++) {
            const square = document.createElement("div");
            const rank = 8 - r;
            const file = "abcdefgh"[fileIndex];
            const squareId = `${file}${rank}`;
            square.id = squareId;
            square.className = `square ${(r + fileIndex) % 2 === 0 ? "white" : "black"}`;

            if (!isNum && i === 0) {
              square.textContent = pieceToSymbol(ch);
            }

            square.onclick = () => handleClick(squareId);
            board.appendChild(square);
            fileIndex++;
          }
        }
      });

      updateStatus();
    }

    function updateStatus() {
      if (game.in_checkmate()) {
        status.textContent = `Checkmate! ${game.turn() === "w" ? "Black" : "White"} wins.`;
      } else if (game.in_check()) {
        status.textContent = `${game.turn() === "w" ? "White" : "Black"} is in check.`;
      } else if (game.in_draw()) {
        status.textContent = "Draw!";
      } else {
        status.textContent = `${game.turn() === "w" ? "White" : "Black"}'s turn.`;
      }
    }

    function handleClick(square) {
      if (game.game_over()) return;

      if (selected) {
        const move = game.move({ from: selected, to: square, promotion: 'q' });
        selected = null;
        renderBoard();
        if (move && gameMode === "computer") {
          setTimeout(makeComputerMove, 500);
        }
      } else {
        const piece = game.get(square);
        if (piece && piece.color === game.turn()) {
          selected = square;
          highlightMoves(square);
        }
      }
    }

    function highlightMoves(square) {
      renderBoard();
      const moves = game.moves({ square, verbose: true });
      document.getElementById(square).classList.add("selected");
      moves.forEach(m => {
        const sq = document.getElementById(m.to);
        if (sq) sq.classList.add("highlight");
      });
    }

    function makeComputerMove() {
      if (game.game_over()) return;
      const moves = game.moves();
      const move = difficulty === 1
        ? moves[Math.floor(Math.random() * moves.length)]
        : moves.find(m => m.includes("x")) || moves[0];
      game.move(move);
      renderBoard();
    }

    function undoMove() {
      game.undo();
      if (gameMode === "computer") game.undo();
      renderBoard();
    }

    function saveGame() {
      localStorage.setItem("xzaviorSavedGame", game.fen());
      alert("Game saved!");
    }

    function restartGame() {
      if (confirm("Restart game?")) {
        game.reset();
        renderBoard();
      }
    }

    // Load saved game if any
    const saved = localStorage.getItem("xzaviorSavedGame");
    if (saved) game.load(saved);

    // Flip board if user chose black
    if (playerColor === "black") {
      board.style.transform = "rotate(180deg)";
    }

    renderBoard();

    // Let computer play first if user picked black
    if (playerColor === "black" && gameMode === "computer" && game.turn() === "w") {
      setTimeout(makeComputerMove, 500);
    }
  </script>
</body>
</html>
